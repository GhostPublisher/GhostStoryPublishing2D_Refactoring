코드 아키텍처 정리

게임 개발에서 Unity가 등장하기 전, 코드 아키텍처는 다음과 같은 흐름으로 구성되었을 것이라 가정했습니다.
Unity 역시 과거 게임 개발의 문제점을 해결또는 편의성을 주기 위해 만들어진 엔진이므로, 과거의 구조를 생각한 후 확장해 보았습니다.


Unity 이전 기본 아키텍처 흐름 ( 가정 )

1. 객체의 기본 구성 (Model, View)
 - 각 객체는 하나의 상태값(데이터)을 담당하는 'Model'을 갖는다.
 - 'View'는 'Model'의 상태를 화면에 보여주기 위한 메소드를 갖는다.
 - 하나의 'Model'은 상황에 따라 여러 개의 'View(출력 담당)'와 연결될 수 있다.
  ( ex. 캐릭터의 상태값을 월드 내 Sprite, UI 체력바, 로그 텍스트 등 다양한 View로 표현 가능 )

2. 메소드들의 조립 (GameFlow)
 - 여러 메소드를 순서대로 연결하고 흐름을 제어하는 역할을 맡는다.
 - '여러 객체의 상태값을 함께 사용해야만 동작하는 로직'을 관리한다.
  ( ex. 공격자와 피격자의 상호작용 )
 - 실행 과정에서 필요한 순서, 대기, 취소 같은 타이밍 제어도 담당한다.

 - 중요한 점은, 이 흐름을 통해 하나의 기능이 완결적으로 이루어진다는 것이다.


3. 보조 기능 (Service)
 - 공통적으로 활용되는 기능을 제공하는 독립적인 단위이다.
 ( ex. 시간 제어, 수학 계산, 경로 탐색, 로깅 같은 범용 기능. )
 - 'GameFlow'가 흐름을 완성할 때 필요한 도구로서 사용된다.

4. 입력 처리 (Input)
 - 유저 입력에 반응하는 입력 메소드가 별도로 존재한다.
 - 입력 메소드는 직접 로직을 실행하기보다, 'GameFlow'를 호출하여 필요한 흐름이 동작하도록 한다.

5. Main 중심 구조
 - 실행은 항상 main에서 시작된다.
 - main은 우선 Model, View, Service, GameFlow, Input을 차례로 생성한 뒤, 이들을 초기화하고 서로 참조 연결함으로써 게임 전체의 실행 흐름을 준비한다.

6. 책임 분산과 원칙

1) Main의 책임을 Load & Bind로 위임
 - 시간이 흐르면서, 생성과 참조가 모두 main에 몰리는 방식은 지나치게 비대해졌다.
 - main의 책임을 Load와 Bind 클래스로 분리하였다.
   - Load: 현재 Scene이나 상황에 필요한 객체들을 불러오고 생성하는 책임
   - Bind: 불러온 객체들이 서로를 참조할 수 있도록 연결해주는 책임

2) 전략 패턴을 통한 Scene 대응
 - Scene마다 사용되는 객체 구성이 달라지므로, 상황에 따라 다른 Load & Bind 클래스를 두고, 이를 전략 패턴으로 교체하는 방식으로 발전하였다.

3) Model과 View의 묶음 관리
 - 1개의 Model과 n개의 View를 하나로 묶어 관리하면 참조 관계를 단순화할 수 있고 유지보수가 편리하다.

4) 단일 입력 관리자 필요성
 - 여러 Input들은 서로 충돌하기 쉬우므로, 이를 통합적으로 관리하는 단일 입력 관리자가 반드시 필요하다.




Unity에 적용하기 위한 고찰

1. Unity의 Component 해석
 - Unity의 컴포넌트는 기본적으로 View 역할을 수행하는 것으로 보입니다.
 - 그러나, 대부분의 View가 단순 출력에서 끝나지 않고, 기능 수행을 위한 내부 상태값을 갖는 것으로 보이기도 합니다.
  ( ex. GridLayoutGroup은 자식 RectTransform을 단순히 보여주는 것이 아니라, 위치를 재배치하는 '작은 흐름(Micro-Flow)'을 실행한다. )

 - 따라서 Unity 컴포넌트는 View를 극소 GameFlow 단위로 해석한 것이라고 볼 수 있습니다.
 - 이 과정에서 View는 자신의 기능을 수행할 하위 요소(Model or 다른 View)를 내부 필드로 직접 보유하게 됩니다.

 - 즉, 컴포넌트는 '완성된 기능'을 제공하는 '작은 GameFlow'라고 해석됩니다.

2. Unity의 GameObject의 해석
 - Unity의 GameObject는 단순한 “빈 그릇”이 아니라, 여러 컴포넌트(=Micro-Flow)를 담는 컨테이너이다.
 - 즉, GameObject는 “n개의 작은 GameFlow의 집합체”로 작동한다.
 - 이는 전통적인 “1개의 Model + n개의 View”라는 단순 구조를 넘어, 복수의 Flow 실행 단위로 확장된 개념이다.

3. 기존 아키텍처에 적용하기 위한 Entity 정의

1) 노출 최소형 Entity

정의
 - 외부에는 상위 EntityGameFlow와 EntityModel만 제공하는 방식.
   - EntityGameFlow : 여러 GameFlow를 조율하고 외부 행동 요청의 진입점 역할을 함.
   - EntityModel : Entity의 상태값(Position, HP, 활성 여부 등)을 외부에 안전하게 노출하는 인터페이스.

특징
 - 외부 접근 경로가 단순해 안정성과 캡슐화에 유리
 - 내부 Flow 교체·추가가 외부 코드에 큰 영향을 주지 않음
 - 세부 Flow에 직접 접근할 수 없고, 반드시 상위 Flow를 통해야 함

2) 전면 노출형 Entity

정의
 - 해당 Entity가 가진 모든 GameFlow를 외부에 그대로 노출하는 방식.
 - 이 경우 EntityGameFlow는 조율자라기보다는 단순한 집합체 성격이 강해지고, EntityModel은 상태 노출만 담당.

특징
- 외부에서 각 Flow에 직접 접근 가능해 유연성과 활용성이 높음
- 개발&디버깅 시 편리하지만, 결합도가 높아 구조 변경 시 수정량이 높음.

4. 참조와 생성주기에 대한 고찰
 - Unity에는 전통적인 의미의 main이 존재하지 않습니다.
 - 따라서 main이 담당하던 역할(생성, 참조 연결, 초기화)을 대신할 Boot 클래스를 두었습니다.
 - Boot는 씬(Scene) 단위로 존재하며, Unity의 Scene 전환 흐름에 따라 자연스럽게 Load & Bind & Remove가 수행됩니다.
 - 즉, Unity의 Scene 단위 진행 구조 위에 기존 아키텍처의 Load & Bind 흐름을 그대로 확장 적용하였습니다.
